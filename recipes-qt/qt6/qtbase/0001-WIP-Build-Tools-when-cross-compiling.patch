From 2cc488056f719e8f4e90bae6247c3739fb185e4b Mon Sep 17 00:00:00 2001
From: Leander Beernaert <leander.beernaert@qt.io>
Date: Mon, 27 Apr 2020 15:04:57 +0200
Subject: [PATCH] WIP: Build Tools when cross compiling

This patch allows tools to be built for the target platform when the
QT_BUILD_TOOLS_WHEN_CROSSCOMPILING parameter is set at configuration
time or before an invocation of qt_add_tool().

To avoid naming conflicts the target tools are suffixed with the
'_native' string. The qt_get_tool_target_name() function can be used to
get the tool name for both scenarios (cross and non-cross compilation).

Every tool now has the property QT_IS_TOOL set to true.

qt_extand_target() has also been updated to check whether the target in
question is a tool and whether we allow tools to be built during cross
compilation before aborting.

Fixes: QTBUG-81901
Change-Id: If4efbc1fae07a4a3a044dd09c9c06be6d517825e
---
 cmake/QtBaseGlobalTargets.cmake     |  5 +++
 cmake/QtBuild.cmake                 | 67 +++++++++++++++++++++++------
 cmake/QtModuleDependencies.cmake.in | 16 +++++++
 cmake/QtSetup.cmake                 |  2 +-
 qmake/CMakeLists.txt                | 11 +++--
 5 files changed, 82 insertions(+), 19 deletions(-)

diff --git a/cmake/QtBaseGlobalTargets.cmake b/cmake/QtBaseGlobalTargets.cmake
index e5006f0e20..e092d5beb7 100644
--- a/cmake/QtBaseGlobalTargets.cmake
+++ b/cmake/QtBaseGlobalTargets.cmake
@@ -115,6 +115,10 @@ if(QT_HOST_PATH)
     set(init_qt_host_path "set(QT_HOST_PATH \"${init_qt_host_path}\" CACHE PATH \"\" FORCE)")
 endif()
 
+if (CMAKE_CROSSCOMPILING AND QT_BUILD_TOOLS_WHEN_CROSSCOMPILING)
+    list(APPEND init_qt_host_path "set(QT_BUILD_TOOLS_WHEN_CROSSCOMPILING \"TRUE\" CACHE BOOL \"\" FORCE)")
+endif()
+
 if(CMAKE_TOOLCHAIN_FILE)
     set(init_original_toolchain_file "set(qt_chainload_toolchain_file \"${CMAKE_TOOLCHAIN_FILE}\")")
 endif()
@@ -166,6 +170,7 @@ endif()
 
 string(REPLACE ";" "\n" init_vcpkg "${init_vcpkg}")
 string(REPLACE ";" "\n" init_platform "${init_platform}")
+string(REPLACE ";" "\n" init_qt_host_path "${init_qt_host_path}")
 string(REPLACE "LITERAL_SEMICOLON" ";" init_platform "${init_platform}")
 qt_compute_relative_path_from_cmake_config_dir_to_prefix()
 configure_file("${CMAKE_CURRENT_SOURCE_DIR}/cmake/qt.toolchain.cmake.in" "${__GlobalConfig_build_dir}/qt.toolchain.cmake" @ONLY)
diff --git a/cmake/QtBuild.cmake b/cmake/QtBuild.cmake
index 4c37e1d4b1..e6aa8459a2 100644
--- a/cmake/QtBuild.cmake
+++ b/cmake/QtBuild.cmake
@@ -1324,9 +1324,20 @@ function(qt_extend_target target)
     # Don't try to extend_target when cross compiling an imported host target (like a tool).
     qt_is_imported_target("${target}" is_imported)
     if(is_imported)
-        return()
+        qt_get_tool_target_name(tool_target ${target})
+        if (TARGET ${tool_target})
+            get_target_property(is_tool_target ${tool_target} QT_IS_TOOL)
+            if (NOT (CMAKE_CROSSCOMPILING AND QT_BUILD_TOOLS_WHEN_CROSSCOMPILING AND is_tool_target))
+                return()
+            else()
+                set(target ${tool_target})
+            endif()
+        else()
+            return()
+        endif()
     endif()
 
+
     if (NOT TARGET "${target}")
         message(FATAL_ERROR "Trying to extend non-existing target \"${target}\".")
     endif()
@@ -2553,7 +2564,7 @@ function(qt_export_tools module_name)
     # If no tools were defined belonging to this module, don't create a config and targets file.
     # Guards against the case when doing a cross-build.
 
-    if(NOT "${module_name}" IN_LIST QT_KNOWN_MODULES_WITH_TOOLS OR CMAKE_CROSSCOMPILING)
+    if(NOT "${module_name}" IN_LIST QT_KNOWN_MODULES_WITH_TOOLS OR (CMAKE_CROSSCOMPILING AND NOT QT_BUILD_TOOLS_WHEN_CROSSCOMPILING))
         return()
     endif()
 
@@ -2582,6 +2593,9 @@ function(qt_export_tools module_name)
             list(APPEND package_deps "${extra_packages}")
         endif()
 
+        if (CMAKE_CROSSCOMPILING AND QT_BUILD_TOOLS_WHEN_CROSSCOMPILING)
+            string(REGEX REPLACE "_native$" "" tool_name ${tool_name})
+        endif()
         set(extra_cmake_statements "${extra_cmake_statements}
 if (NOT QT_NO_CREATE_TARGETS)
     get_property(is_global TARGET ${INSTALL_CMAKE_NAMESPACE}::${tool_name} PROPERTY IMPORTED_GLOBAL)
@@ -3075,7 +3089,7 @@ function(qt_add_executable name)
         set(arg_INSTALL_DIRECTORY "${INSTALL_BINDIR}")
     endif()
 
-    if (ANDROID)
+    if (FALSE)
         add_library("${name}" MODULE)
         qt_android_apply_arch_suffix("${name}")
         qt_android_generate_deployment_settings("${name}")
@@ -3491,7 +3505,7 @@ endfunction()
 
 # Sets QT_WILL_BUILD_TOOLS if tools will be built.
 function(qt_check_if_tools_will_be_built)
-    if(NOT CMAKE_CROSSCOMPILING AND NOT QT_FORCE_FIND_TOOLS)
+    if((NOT CMAKE_CROSSCOMPILING AND NOT QT_FORCE_FIND_TOOLS) OR QT_BUILD_TOOLS_WHEN_CROSSCOMPILING)
         set(will_build_tools TRUE)
     else()
         set(will_build_tools FALSE)
@@ -3768,6 +3782,16 @@ function(qt_get_main_cmake_configuration out_var)
     set("${out_var}" "${config}" PARENT_SCOPE)
 endfunction()
 
+
+function(qt_get_tool_target_name output_name name)
+    if (CMAKE_CROSSCOMPILING AND QT_BUILD_TOOLS_WHEN_CROSSCOMPILING)
+        set(${output_name} ${name}_native PARENT_SCOPE)
+    else()
+        set(${output_name} ${name} PARENT_SCOPE)
+    endif()
+endfunction()
+
+
 # This function is used to define a "Qt tool", such as moc, uic or rcc.
 # The BOOTSTRAP option allows building it as standalone program, otherwise
 # it will be linked against QtCore.
@@ -3788,10 +3812,14 @@ function(qt_add_tool name)
     if(TARGET ${full_name})
         get_property(path TARGET ${full_name} PROPERTY LOCATION)
         message(STATUS "Tool '${full_name}' was found at ${path}.")
-        return()
+        if (CMAKE_CROSSCOMPILING AND NOT QT_BUILD_TOOLS_WHEN_CROSSCOMPILING)
+            return()
+        endif()
     endif()
 
-    if(arg_TOOLS_TARGET AND NOT QT_WILL_BUILD_TOOLS)
+    qt_get_tool_target_name(target_name ${name})
+
+    if(arg_TOOLS_TARGET AND (NOT QT_WILL_BUILD_TOOLS OR QT_BUILD_TOOLS_WHEN_CROSSCOMPILING))
         set(tools_package_name "Qt6${arg_TOOLS_TARGET}Tools")
         message(STATUS "Searching for tool '${full_name}' in package ${tools_package_name}.")
 
@@ -3827,7 +3855,9 @@ function(qt_add_tool name)
             qt_internal_append_known_modules_with_tools("${arg_TOOLS_TARGET}")
             get_property(path TARGET ${full_name} PROPERTY LOCATION)
             message(STATUS "${full_name} was found at ${path} using package ${tools_package_name}.")
-            return()
+            if (NOT QT_BUILD_TOOLS_WHEN_CROSSCOMPILING)
+                return()
+            endif()
         endif()
     endif()
 
@@ -3870,7 +3900,7 @@ function(qt_add_tool name)
         set(no_install NO_INSTALL)
     endif()
 
-    qt_add_executable("${name}" OUTPUT_DIRECTORY "${QT_BUILD_DIR}/${INSTALL_BINDIR}"
+    qt_add_executable("${target_name}" OUTPUT_DIRECTORY "${QT_BUILD_DIR}/${INSTALL_BINDIR}"
         ${bootstrap}
         ${no_qt}
         ${no_install}
@@ -3890,12 +3920,21 @@ function(qt_add_tool name)
         TARGET_COMPANY "${arg_TARGET_COMPANY}"
         TARGET_COPYRIGHT "${arg_TARGET_COPYRIGHT}"
     )
-    qt_internal_add_target_aliases("${name}")
+    qt_internal_add_target_aliases("${target_name}")
+
+    if (NOT target_name STREQUAL name)
+        set_target_properties(${target_name} PROPERTIES
+            OUTPUT_NAME ${name}
+            EXPORT_NAME ${name}
+        )
+    endif()
+
+    set_target_properties(${target_name} PROPERTIES QT_IS_TOOL TRUE)
 
     # If building with a multi-config configuration, the main configuration tool will be placed in
     # ./bin, while the rest will be in <CONFIG> specific subdirectories.
     qt_get_tool_cmake_configuration(tool_cmake_configuration)
-    set_target_properties("${name}" PROPERTIES
+    set_target_properties("${target_name}" PROPERTIES
         RUNTIME_OUTPUT_DIRECTORY_${tool_cmake_configuration} "${QT_BUILD_DIR}/${INSTALL_BINDIR}"
     )
 
@@ -3904,17 +3943,17 @@ function(qt_add_tool name)
         qt_internal_append_known_modules_with_tools("${arg_TOOLS_TARGET}")
 
         # Also append the tool to the module list.
-        qt_internal_append_known_module_tool("${arg_TOOLS_TARGET}" "${name}")
+        qt_internal_append_known_module_tool("${arg_TOOLS_TARGET}" "${target_name}")
 
-        qt_install(TARGETS "${name}"
+        qt_install(TARGETS "${target_name}"
                    EXPORT "${INSTALL_CMAKE_NAMESPACE}${arg_TOOLS_TARGET}ToolsTargets"
                    DESTINATION ${INSTALL_TARGETS_DEFAULT_ARGS})
-        qt_apply_rpaths(TARGET "${name}" INSTALL_PATH "${INSTALL_BINDIR}" RELATIVE_RPATH)
+        qt_apply_rpaths(TARGET "${target_name}" INSTALL_PATH "${INSTALL_BINDIR}" RELATIVE_RPATH)
 
     endif()
 
     if(QT_FEATURE_separate_debug_info AND (UNIX OR MINGW))
-        qt_enable_separate_debug_info(${name} ${INSTALL_BINDIR})
+        qt_enable_separate_debug_info(${target_name} ${INSTALL_BINDIR})
     endif()
 endfunction()
 
diff --git a/cmake/QtModuleDependencies.cmake.in b/cmake/QtModuleDependencies.cmake.in
index ffb9e8a5d3..4cc8308ff2 100644
--- a/cmake/QtModuleDependencies.cmake.in
+++ b/cmake/QtModuleDependencies.cmake.in
@@ -31,6 +31,14 @@ set(_tool_deps "@main_module_tool_deps@")
 set(BACKUP_CMAKE_SIZEOF_VOID_P "${CMAKE_SIZEOF_VOID_P}")
 set(CMAKE_SIZEOF_VOID_P "")
 
+if(QT_HOST_PATH)
+     # Make sure that the tools find the host tools first
+     set(BACKUP_CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH})
+     set(BACKUP_CMAKE_FIND_ROOT_PATH ${CMAKE_FIND_ROOT_PATH})
+     list(PREPEND CMAKE_PREFIX_PATH "${QT_HOST_PATH}")
+     list(PREPEND CMAKE_FIND_ROOT_PATH "${QT_HOST_PATH}")
+endif()
+
 foreach(_target_dep ${_tool_deps})
     list(GET _target_dep 0 pkg)
     list(GET _target_dep 1 version)
@@ -40,9 +48,17 @@ foreach(_target_dep ${_tool_deps})
     if (NOT ${pkg}_FOUND)
         set(@INSTALL_CMAKE_NAMESPACE@@target@_FOUND FALSE)
         set(CMAKE_SIZEOF_VOID_P "${BACKUP_CMAKE_SIZEOF_VOID_P}")
+        if(QT_HOST_PATH)
+             set(CMAKE_PREFIX_PATH ${BACKUP_CMAKE_PREFIX_PATH})
+             set(CMAKE_FIND_ROOT_PATH ${BACKUP_CMAKE_FIND_ROOT_PATH})
+        endif()
         return()
     endif()
 endforeach()
+if(QT_HOST_PATH)
+     set(CMAKE_PREFIX_PATH ${BACKUP_CMAKE_PREFIX_PATH})
+     set(CMAKE_FIND_ROOT_PATH ${BACKUP_CMAKE_FIND_ROOT_PATH})
+endif()
 set(CMAKE_SIZEOF_VOID_P "${BACKUP_CMAKE_SIZEOF_VOID_P}")
 
 # note: target_deps example: "Qt6Core\;5.12.0;Qt6Gui\;5.12.0"
diff --git a/cmake/QtSetup.cmake b/cmake/QtSetup.cmake
index 39142fa332..5ff639c17e 100644
--- a/cmake/QtSetup.cmake
+++ b/cmake/QtSetup.cmake
@@ -126,7 +126,7 @@ option(QT_NO_MAKE_TESTS "Should tests be built as part of the default 'all' targ
 # Like in qttools/assistant/assistant.pro, load(qt_app), which is guarded by a qtNomakeTools() call.
 
 option(QT_NO_MAKE_TOOLS "Should tools be built as part of the default 'all' target."
-       "${CMAKE_CROSSCOMPILING}")
+       "${CMAKE_CROSSCOMPILING} AND NOT ${QT_BUILD_TOOLS_WHEN_CROSSCOMPILING}")
 
 include(CTest)
 enable_testing()
diff --git a/qmake/CMakeLists.txt b/qmake/CMakeLists.txt
index fa7d50f234..f0d4473ebe 100644
--- a/qmake/CMakeLists.txt
+++ b/qmake/CMakeLists.txt
@@ -246,15 +246,18 @@ qt_extend_target(qmake CONDITION CLANG AND WIN32
         "-Wno-microsoft-enum-value"
 )
 
+# special case begin
+qt_get_tool_target_name(target_name qmake)
 # special case:
-set_target_properties(qmake PROPERTIES
+set_target_properties(${target_name} PROPERTIES
     AUTOMOC OFF
     AUTORCC OFF
     AUTOUIC OFF
 )
 
-qt_internal_add_link_flags_gc_sections(qmake PRIVATE) # special case
+qt_internal_add_link_flags_gc_sections(${target_name} PRIVATE) # special case
 
-qt_enable_msvc_cplusplus_define(qmake PUBLIC) # special case
-qt_skip_warnings_are_errors(qmake) # special case
+qt_enable_msvc_cplusplus_define(${target_name} PUBLIC) # special case
+qt_skip_warnings_are_errors(${target_name}) # special case
 
+# special case end
